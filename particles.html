<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Saturn Aeternum - 交互式3D土星</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'PingFang SC', 'Inter', sans-serif;
        }

        canvas {
            display: block;
        }

        #ui-container {
            position: absolute;
            top: 20px;
            left: 20px;
            color: rgba(255, 255, 255, 0.9);
            pointer-events: none;
            z-index: 10;
        }

        h1 {
            margin: 0;
            font-size: 1.8rem;
            font-weight: 200;
            letter-spacing: 4px;
            text-transform: uppercase;
            text-shadow: 0 0 10px rgba(160, 196, 255, 0.5);
        }

        p {
            font-size: 0.9rem;
            margin-top: 5px;
            opacity: 0.8;
            font-weight: 300;
        }

        #status {
            display: inline-block;
            width: 8px;
            height: 8px;
            background-color: #ff4444;
            border-radius: 50%;
            margin-right: 8px;
            box-shadow: 0 0 5px #ff4444;
        }

        #status.active {
            background-color: #44ff44;
            box-shadow: 0 0 5px #44ff44;
        }

        #interaction-hint {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.7);
            font-size: 0.9rem;
            letter-spacing: 2px;
            text-align: center;
            opacity: 0;
            transition: opacity 1s;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.8);
        }

        .btn {
            pointer-events: auto;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.15);
            color: white;
            padding: 8px 20px;
            border-radius: 30px;
            cursor: pointer;
            margin-top: 15px;
            font-size: 0.85rem;
            backdrop-filter: blur(10px);
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            text-decoration: none;
            display: inline-block;
            letter-spacing: 1px;
        }

        .btn:hover {
            background: rgba(255, 255, 255, 0.15);
            border-color: rgba(255, 255, 255, 0.6);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        #loader {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 1.2rem;
            letter-spacing: 4px;
            font-weight: 200;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% {
                opacity: 0.4;
            }

            50% {
                opacity: 1;
                text-shadow: 0 0 15px rgba(255, 255, 255, 0.5);
            }

            100% {
                opacity: 0.4;
            }
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
                "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.x/+esm"
            }
        }
    </script>
</head>

<body>
    <div id="ui-container">
        <div style="display: flex; align-items: center; margin-bottom: 10px;">
            <div id="status"></div>
            <span style="font-size: 0.75rem; letter-spacing: 1px;">视觉引擎 / 手势追踪</span>
        </div>
        <h1>Saturn Aeternum</h1>
        <p>核心稳定性: <span id="stability-val">100%</span></p>
        <a href="blog.html?post=5" class="btn">← 返回日志</a>
        <button id="fs-btn" class="btn">开启沉浸模式</button>
    </div>

    <div id="loader">正在初始化物理引擎...</div>
    <div id="interaction-hint">向摄像头展示手掌以控制引力</div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';

        // --- Configuration ---
        const CONFIG = {
            particleCount: 25000, // Increased for "Exquisite" feel
            saturnRadius: 5,
            ringInnerRadius: 7.5,
            ringOuterRadius: 22,
            G: 30,
            baseColor: new THREE.Color(0xd2b48c),
            chaosThreshold: 20
        };

        const state = {
            handDetected: false,
            pinchDistance: 1.0,
            zoomLevel: 1.0,
            chaosFactor: 0.0,
            time: 0
        };

        // --- Scene ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050505, 0.015);

        const camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 8, 30);

        const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.0;
        document.body.appendChild(renderer.domElement);

        // --- Post Processing ---
        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0.1;
        bloomPass.strength = 1.0;
        bloomPass.radius = 0.8;

        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // --- Stars Background ---
        const starsGeo = new THREE.BufferGeometry();
        const starsCount = 3000;
        const starPos = new Float32Array(starsCount * 3);
        for (let i = 0; i < starsCount * 3; i++) {
            starPos[i] = (Math.random() - 0.5) * 400;
        }
        starsGeo.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
        const starsMat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.2, transparent: true, opacity: 0.8 });
        const starField = new THREE.Points(starsGeo, starsMat);
        scene.add(starField);

        // --- Saturn Shader Material (Atmosphere) ---
        const vertexShader = `
            varying vec3 vNormal;
            varying vec3 vPosition;
            void main() {
                vNormal = normalize(normalMatrix * normal);
                vPosition = (modelViewMatrix * vec4(position, 1.0)).xyz;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;

        const fragmentShader = `
            varying vec3 vNormal;
            varying vec3 vPosition;
            uniform vec3 color;
            
            void main() {
                float intensity = pow(0.6 - dot(vNormal, vec3(0, 0, 1.0)), 4.0);
                // Base planet color with some procedural bands logic (simplified)
                float band = sin(vPosition.y * 10.0) * 0.1 + 0.9;
                vec3 finalColor = color * band + vec3(0.5, 0.7, 1.0) * intensity; 
                gl_FragColor = vec4(finalColor, 1.0);
            }
        `;

        const saturnGeo = new THREE.SphereGeometry(CONFIG.saturnRadius, 64, 64);
        const saturnMat = new THREE.ShaderMaterial({
            uniforms: { color: { value: new THREE.Vector3(0.82, 0.70, 0.55) } },
            vertexShader,
            fragmentShader,
            side: THREE.FrontSide
        });
        const saturn = new THREE.Mesh(saturnGeo, saturnMat);
        scene.add(saturn);

        // --- Particles ---
        const particlesGeometry = new THREE.BufferGeometry();
        const positions = new Float32Array(CONFIG.particleCount * 3);
        const colors = new Float32Array(CONFIG.particleCount * 3);
        const sizes = new Float32Array(CONFIG.particleCount);

        const particleVelocities = [];
        const chaosOffsets = new Float32Array(CONFIG.particleCount * 3);

        const color1 = new THREE.Color(0xffeec2); // Gold
        const color2 = new THREE.Color(0xa0c4ff); // Ice Blue
        const color3 = new THREE.Color(0x8b7355); // Dust

        for (let i = 0; i < CONFIG.particleCount; i++) {
            const angle = Math.random() * Math.PI * 2;
            const r = CONFIG.ringInnerRadius + Math.random() * (CONFIG.ringOuterRadius - CONFIG.ringInnerRadius);
            const speed = Math.sqrt(CONFIG.G / r) * 0.5 * (0.9 + Math.random() * 0.2);

            const x = Math.cos(angle) * r;
            const y = (Math.random() - 0.5) * 0.2 * (r / 5); // Thinner rings
            const z = Math.sin(angle) * r;

            positions[i * 3] = x;
            positions[i * 3 + 1] = y;
            positions[i * 3 + 2] = z;

            // Color gradient based on radius
            const t = (r - CONFIG.ringInnerRadius) / (CONFIG.ringOuterRadius - CONFIG.ringInnerRadius);
            let c = new THREE.Color().copy(color1).lerp(color3, t);
            if (Math.random() > 0.8) c = color2; // Sparkling ice

            colors[i * 3] = c.r;
            colors[i * 3 + 1] = c.g;
            colors[i * 3 + 2] = c.b;

            sizes[i] = Math.random() * 0.15 + 0.05;

            particleVelocities.push({ angle, radius: r, speed, yBase: y });

            chaosOffsets[i * 3] = (Math.random() - 0.5);
            chaosOffsets[i * 3 + 1] = (Math.random() - 0.5);
            chaosOffsets[i * 3 + 2] = (Math.random() - 0.5);
        }

        particlesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        particlesGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        particlesGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

        const pMaterial = new THREE.PointsMaterial({
            vertexColors: true,
            size: 0.2, // Will be overridden by shader if we used ShaderMaterial, but sticking to PointsMaterial for ease + size attenuation
            sizeAttenuation: true,
            transparent: true,
            opacity: 0.8,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });

        const particles = new THREE.Points(particlesGeometry, pMaterial);
        scene.add(particles);

        const pointLight = new THREE.PointLight(0xffffff, 2, 80);
        pointLight.position.set(20, 10, 20);
        scene.add(pointLight);

        // --- Logic ---
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.enableZoom = true; // Enable Zoom by default
        controls.autoRotate = true; // "Standard State" - auto rotate
        controls.autoRotateSpeed = 0.5;

        // --- Hand Tracking ---
        let handLandmarker;
        let webcamRunning = false;
        const video = document.createElement('video');
        video.autoplay = true;

        async function initWebcam() {
            // 1. Check for Secure Context (HTTPS)
            if (window.location.hostname !== 'localhost' && window.location.protocol !== 'https:') {
                document.getElementById('loader').innerHTML = "摄像头需要 HTTPS 环境<br><a href='" + window.location.href.replace('http:', 'https:') + "' style='color: #44ff44; margin-top: 10px; display: inline-block; font-size: 0.8em;'>点击切换到安全模式</a>";
                return;
            }

            try {
                const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm");
                handLandmarker = await HandLandmarker.createFromOptions(vision, {
                    baseOptions: { modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`, delegate: "GPU" },
                    runningMode: "VIDEO", numHands: 1
                });

                document.getElementById('loader').textContent = "正在请求摄像头权限...";

                const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                video.srcObject = stream;
                video.addEventListener("loadeddata", predict);
                webcamRunning = true;

                document.getElementById('loader').style.display = 'none';
                document.getElementById('interaction-hint').style.opacity = '1';
                document.getElementById('status').classList.add('active');
            } catch (e) {
                console.error(e);
                let msg = "视觉模块加载失败";
                if (e.name === 'NotAllowedError' || e.name === 'PermissionDeniedError') {
                    msg = "访问被拒绝: 请允许摄像头权限";
                } else if (!navigator.mediaDevices) {
                    msg = "浏览器不支持或未加密(HTTP)";
                }
                document.getElementById('loader').textContent = msg;
            }
        }

        let lastTime = -1;
        async function predict() {
            if (video.currentTime !== lastTime) {
                lastTime = video.currentTime;
                const result = handLandmarker.detectForVideo(video, performance.now());
                if (result.landmarks.length > 0) {
                    state.handDetected = true;
                    // Pinch detection
                    const lm = result.landmarks[0];
                    const dist = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y);
                    // Map distance (0.02 - 0.2) to State (0 - 1)
                    state.pinchDistance = THREE.MathUtils.clamp((dist - 0.02) * 6, 0, 1);
                } else {
                    state.handDetected = false;
                }
            }
            requestAnimationFrame(predict);
        }

        // --- Cycle ---
        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            state.time += delta;

            if (state.handDetected) {
                // --- Hand Control Mode ---
                controls.enabled = false; // Disable mouse controls

                // Target Distance Calculation
                // Pinch (0) = Far (Stable). Open (1) = Close (Chaos).
                const targetDist = THREE.MathUtils.lerp(45, 8, state.pinchDistance);
                const currentDist = camera.position.length();
                const newDist = THREE.MathUtils.lerp(currentDist, targetDist, delta * 3);
                camera.position.setLength(newDist);
                camera.lookAt(0, 0, 0);

                // Chaos Trigger (Close distance < 12)
                if (newDist < 12) {
                    state.chaosFactor = THREE.MathUtils.lerp(state.chaosFactor, 1.0, delta * 4);
                } else {
                    state.chaosFactor = THREE.MathUtils.lerp(state.chaosFactor, 0.0, delta * 2);
                }
            } else {
                // --- Standard/Mouse Mode ---
                controls.enabled = true;
                controls.update(); // Handle auto-rotate and damping

                // Slowly decay chaos if we just lost hand tracking
                state.chaosFactor = THREE.MathUtils.lerp(state.chaosFactor, 0.0, delta * 2);
            }

            // Common Visual Updates
            const currentDist = camera.position.length();

            // UI
            const stability = Math.round((1 - state.chaosFactor) * 100);
            document.getElementById('stability-val').textContent = stability + "%";
            document.getElementById('stability-val').style.color = stability < 40 ? '#ff4444' : '#fff';

            // Visuals: Closer = Brighter
            const brightness = THREE.MathUtils.clamp(50 / currentDist, 0.5, 3.0);
            bloomPass.strength = brightness * 0.6;
            saturnMat.uniforms.color.value.setScalar(brightness * 0.3); // Pulse core

            // Update Particles
            const pos = particles.geometry.attributes.position.array;
            for (let i = 0; i < CONFIG.particleCount; i++) {
                const v = particleVelocities[i];
                v.angle += v.speed * delta * (1 + state.chaosFactor * 3); // Faster when chaotic

                let x, y, z;
                // Chaos Noise
                if (state.chaosFactor > 0.01) {
                    const r = v.radius + (Math.sin(state.time * 10 + i) * state.chaosFactor * 5); // Explode radius
                    const yNoise = (Math.cos(state.time * 20 + i) * state.chaosFactor * 5);    // Vertical explode

                    x = Math.cos(v.angle) * r + chaosOffsets[i * 3] * state.chaosFactor;
                    y = v.yBase + yNoise;
                    z = Math.sin(v.angle) * r + chaosOffsets[i * 3 + 2] * state.chaosFactor;
                } else {
                    x = Math.cos(v.angle) * v.radius;
                    y = v.yBase + Math.sin(v.angle * 2 + state.time) * 0.05;
                    z = Math.sin(v.angle) * v.radius;
                }
                pos[i * 3] = x;
                pos[i * 3 + 1] = y;
                pos[i * 3 + 2] = z;
            }
            particles.geometry.attributes.position.needsUpdate = true;
            saturn.rotation.y += 0.0005;

            controls.update();
            composer.render();
        }

        animate();
        initWebcam();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });
        document.getElementById('fs-btn').onclick = () => {
            !document.fullscreenElement ? document.documentElement.requestFullscreen() : document.exitFullscreen();
        }

    </script>
</body>

</html>